_target_: src.losses.objective.Objective

n_step_max: ${max:${train.train_steps}, ${train.val_steps}, ${train.test_steps}}
decay: 0.99
quat_weight: 1.0
quat_loss_type: geodesic # Options: geodesic, chordal
quat_norm_weight: 0.1

weights:
  pred_x: 1.0
  pred_z: 1.0
  recon_z: 0.1
  isometric: 0.01
  backward_roll_z: 0.01
  backward_roll_x: 0.01

targets:
  # 1. Prediction Loss: || x_gt - D(z_pred) ||^2
  # t = k ~ k+N, Naturally include reconstruction loss for initial state
  pred_x:
    _target_: src.losses.components.quat.QuatLoss

    n_step_max: ${...n_step_max}
    weight_decay: ${...decay}

    weight: ${...weights.pred_x}
    key_pred: x_traj          # [B, N+1, D]
    key_target: x_traj_gt     # [B, N+1, D]
    quat_indices: ${data.quat_indices}
    quat_loss_type: ${...quat_loss_type}
    quat_norm_weight: ${...quat_norm_weight}
    quat_weight: ${...quat_weight}

  # 2. Latent Prediction Loss: || E(x_gt) - z_pred ||^2
  # t = k ~ k+N
  pred_z:
    _target_: src.losses.components.base.BaseLoss

    n_step_max: ${...n_step_max}
    weight_decay: ${...decay}
    
    weight: ${...weights.pred_z}
    key_pred: z_traj          # [B, N+1, D]
    key_target: z_traj_gt     # [B, N+1, D]

  # 3. Latent Consistency Loss: || z_pred - E(D(z_pred)) ||^2
  # t = k ~ k+N
  recon_z:
    _target_: src.losses.components.base.BaseLoss

    n_step_max: ${...n_step_max}
    weight_decay: ${...decay}

    weight: ${...weights.recon_z}
    key_pred: z_traj_re       
    key_target: z_traj        

  # 4. Isometry Loss: || D_x^2 - s * D_z^2 ||^2
  # Random subsampling
  isometric:
    _target_: src.losses.components.isometry.IsometryLoss

    n_step_max: ${...n_step_max}
    weight_decay: ${...decay}

    weight: ${...weights.isometric}

    key_pred: z_traj_gt
    key_target: x_traj_gt

    quat_indices: ${data.quat_indices}
    quat_loss_type: ${...quat_loss_type}
    quat_norm_weight: 0.0

    min_scale: 1.0
    sample_size: 512

  # 5. Backward Rolling Prediction Loss (Z-space & X-space Combined)
  # Start from z_{t+N}, roll back to z_t
  backward_roll:
    _target_: src.losses.components.backward.BackwardRollingLoss

    n_step_max: ${...n_step_max}
    weight_decay: 1.0 # Not used for rolling loss

    weight: 1.0 # Base weight is 1.0, individual weights are controlled below

    key_z: z_traj_gt
    key_x: x_traj_gt
    key_A_params: A_params
    key_B: B
    key_u: u_future
    eigval_max: ${model.eigval_max}
    
    # Combined weights
    weight_z: ${...weights.backward_roll_z}
    weight_x: ${...weights.backward_roll_x}
